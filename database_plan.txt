That's a solid architectural vision! Moving to PostgreSQL for user data and session metadata, while potentially keeping Redis for the high-throughput chat history itself, is a robust and scalable approach. Integrating SQLAlchemy, Alembic, Passlib, JWT, etc., brings us much closer to a production-ready system.
Hereâ€™s a lower-level plan breakdown, focusing on the steps and components involved, without writing the actual code yet:
Database Setup (PostgreSQL & SQLAlchemy/Alembic):
Docker Compose: Add a postgres service definition (similar to the commented-out one) using an official image (e.g., postgres:15-alpine), configure environment variables for user/password/db (ideally sourcing from .env), and map a persistent named volume for data. Make the backend service depends_on the postgres service.
Configuration: Add DATABASE_URL (e.g., postgresql+asyncpg://user:password@postgres/appdb) to core/config.py. Note the +asyncpg for async SQLAlchemy. Add asyncpg to pyproject.toml dependencies.
SQLAlchemy Core: Create a core/database.py file. Initialize the async SQLAlchemy engine using the DATABASE_URL. Create an async session factory (async_sessionmaker). Define a base class for declarative models (DeclarativeBase).
Alembic Init: Run alembic init backend/alembic to create the migration environment.
Alembic Config: Configure backend/alembic/env.py to use the SQLAlchemy engine and model metadata (from core/database.py and future model files). Configure alembic.ini to point to the correct database URL.
Database Dependency: Create an async dependency provider (get_db_session in core/dependencies.py) that yields an async session from the session factory.
User Model & Authentication:
Dependencies: Add passlib[bcrypt], python-jose[cryptography], and python-multipart (for form data in token endpoint) to pyproject.toml.
User Schema (schemas/user.py): Define the SQLAlchemy User model table (e.g., id, username, email, hashed_password, is_active, created_at).
User Pydantic Models (models/user.py): Define models for API interaction: UserBase, UserCreate (includes plaintext password), UserRead (excludes password), UserInDB (includes hashed password).
Alembic Migration (User): Run alembic revision --autogenerate -m "Create users table" and alembic upgrade head.
Security Utils (utils/security.py): Implement functions for password hashing/verification (verify_password, get_password_hash) using passlib. Implement JWT functions (create_access_token, logic to decode/verify token) using python-jose. Add constants for SECRET_KEY, ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES (get these from core/config.py).
User CRUD (crud/user_crud.py): Implement async functions: get_user_by_email, get_user_by_username, create_user (hashes password before saving). These will take an AsyncSession object.
Authentication Router (api/auth.py): Create a new router. Implement the /token endpoint using OAuth2PasswordRequestForm. This endpoint will authenticate the user (using CRUD functions and verify_password), and if successful, return a JWT access token (using create_access_token).
User Router (api/user.py - Optional): Create a router for user operations like registration (POST /users/) which uses crud.create_user.
Current User Dependency (core/dependencies.py): Create get_current_active_user dependency. It will depend on an OAuth2PasswordBearer scheme, decode the token using security utils, fetch the user from the DB using CRUD, and return the active user object or raise an exception.
Integrate Auth Router: Include the auth_router (and user_router if created) in main.py.
Session/History Model Linking & Storage Strategy:
Decision: Confirm the strategy. Based on your description, let's assume Postgres stores User & Session Metadata, Redis stores Session Content.
Session Schema (schemas/session.py - New): Define SQLAlchemy ConversationSession model table (e.g., id (PK), session_uuid (UUID, matches Redis key, unique per user or globally?), user_id (FK to users.id), created_at, last_accessed_at, title (optional, maybe auto-generated later)). Add relationship back to User.
Session Pydantic Models (models/session.py - New): Define SessionBase, SessionRead, etc.
Alembic Migration (Session): Run alembic revision --autogenerate -m "Create conversation_sessions table" and alembic upgrade head.
Session CRUD (crud/session_crud.py - New): Implement async functions: create_session (takes user_id, session_uuid), get_session_by_uuid, get_sessions_by_user, update_session_last_accessed, delete_session. These take an AsyncSession.
Refactor History & Chat Logic:
History CRUD (crud/history_crud.py): Redis functions (add_history_entry, get_history, clear_session_history) remain largely the same as they only interact with Redis via the session_id. We might rename clear_session_history to clear_redis_history for clarity.
History Service (services/history_service.py):
Modify save_history_entry: Now needs db: AsyncSession and current_user: User dependencies (in addition to redis_conn). Before calling history_crud.add_history_entry, check if session metadata exists in Postgres for this session_id and user_id. If not, call session_crud.create_session. Update session_crud.update_session_last_accessed.
Modify get_history: Needs current_user dependency to authorize access. Verify the requested session_id actually belongs to the current_user by checking Postgres metadata before fetching from Redis.
Modify clear_history: Needs db and current_user dependencies. Verify ownership in Postgres. Call both session_crud.delete_session (Postgres) and history_crud.clear_redis_history (Redis).
Add list_user_sessions(db: AsyncSession, current_user: User): Calls session_crud.get_sessions_by_user.
Chat Service (services/chat_service.py):
Needs current_user: User = Depends(get_current_active_user) added to function signatures.
Pass db and current_user down to the relevant history_service calls.
API Layer Integration:
Protect Chat Endpoints: Add current_user: User = Depends(get_current_active_user) to chat_endpoint and chat_stream_endpoint in api/chat.py. Pass the current_user down when calling the service functions.
New Session Endpoint: Create api/session.py router. Add GET /sessions/ endpoint, protected by auth, calling history_service.list_user_sessions.
Client (backend/app.py) Update:
Login: Prompt for username/password. Call /api/v1/auth/token to get JWT. Store the token. Handle login failure.
List Sessions: If login succeeds, call GET /api/v1/sessions/ using an Authorization: Bearer <token> header.
Session Selection: Display sessions returned by the API. Prompt user to select or start new. If new, generate UUID locally.
Chat: Send session_id (selected or new) and the Authorization header with the token to the chat endpoints (/ or /stream).
This detailed plan sets up a robust system with user accounts, authenticated session management, and persistent storage, separating metadata (Postgres) from history content (Redis). Does this align with your vision?
